diff --git arch/arm/dts/s5p4418-zh-blackdragon.dts arch/arm/dts/s5p4418-zh-blackdragon.dts
index 275b9c6..bfb7c09 100644
--- arch/arm/dts/s5p4418-zh-blackdragon.dts
+++ arch/arm/dts/s5p4418-zh-blackdragon.dts
@@ -90,11 +90,28 @@
 		i2c-gpio,delay-us = <12>;
 		ub927928_gpio@0c{
 			compatible = "mediatek,ub9xx";
-			gpios-en = <&gpio_alv 0 1>;
 			reg = <0x0c>;
 		};
 	};
-
+	nx_i2c_gpio:i2c@3 {
+		compatible = "i2c-gpio";
+		gpios = <&gpio_d 5 0>,
+		      <&gpio_d 4 0>;	
+		i2c-gpio,delay-us = <1>;
+		nx_i2c_gpio@0c{
+			compatible = "nexell,nx_i2c";
+			reg = <0x44>;
+			};
+	};
+/*
+	nx_i2c:i2c@c00a5000 {
+		status = "okay";
+		nx_i2c@44{
+			compatible = "nexell,nx_i2c";
+			reg = <0x44>;
+			};
+	};
+*/
 	dp0:dp@c0102800 {
 	        status = "okay";
 	        module = <0>;
diff --git arch/arm/lib/bootm.c arch/arm/lib/bootm.c
index 6d653d1..7bdb2da 100644
--- arch/arm/lib/bootm.c
+++ arch/arm/lib/bootm.c
@@ -381,8 +381,8 @@ int bootz_setup(ulong image, ulong *start, ulong *end)
 	*start = zi->zi_start;
 	*end = zi->zi_end;
 
-	printf("Kernel image @ %#08lx [ %#08lx - %#08lx ]\n", image, *start,
-	      *end);
+	/* printf("Kernel image @ %#08lx [ %#08lx - %#08lx ]\n", image, *start, */
+	/*       *end); */
 
 	return 0;
 }
diff --git board/s5p4418/zh_blackdragon/board.c board/s5p4418/zh_blackdragon/board.c
index eb59be4..61e6b6f 100644
--- board/s5p4418/zh_blackdragon/board.c
+++ board/s5p4418/zh_blackdragon/board.c
@@ -262,6 +262,9 @@ int board_late_init(void)
 	ub927928_init_s();
 #endif
 
+/* #ifdef CONFIG_CHECK_REARCAM */
+	nx_i2c_init_s();
+/* #endif */
 	board_backlight_enable();
 
 #ifdef CONFIG_USB_CHARGE
@@ -272,7 +275,7 @@ int board_late_init(void)
 #define ALIVE_SCRATCH1_READ_REGISTER (0xc00108b4)
 #define ALIVE_SCRATCH1_RESET_REGISTER (0xc00108ac)
 #define RECOVERY_SIGNATURE (0x52455343) /* (ASCII) : R.E.S.C */
-	printf("signature --> 0x%x\n", readl(ALIVE_SCRATCH1_READ_REGISTER));
+	/* printf("signature --> 0x%x\n", readl(ALIVE_SCRATCH1_READ_REGISTER)); */
 	if (readl(ALIVE_SCRATCH1_READ_REGISTER) == RECOVERY_SIGNATURE) {
 		printf("reboot recovery!!!!\n");
 		writel(0xffffffff, ALIVE_SCRATCH1_RESET_REGISTER);
@@ -368,3 +371,20 @@ void power_init_board(void)
 }
 #endif
 
+int board_rearcam_check(void)
+{
+	static int rearcam_on = 0;
+	static int rearcam_checked = 0;
+
+	if (!rearcam_checked) {
+		rearcam_checked = 1;
+
+		nx_gpio_set_pad_function(1/*gpio_b*/, 11, 1);
+		nx_gpio_set_pull_mode(1, 11, nx_gpio_pull_down);
+		nx_gpio_set_output_enable(1, 11, 0);
+		nx_gpio_set_detect_enable(1, 11, 1);
+		rearcam_on = !nx_gpio_get_input_value(1/*gpio_b*/, 11);
+	}
+
+	return rearcam_on;
+}
diff --git common/board_r.c common/board_r.c
index 75ee43e..6c59723 100644
--- common/board_r.c
+++ common/board_r.c
@@ -438,7 +438,7 @@ static int initr_onenand(void)
 #ifdef CONFIG_GENERIC_MMC
 static int initr_mmc(void)
 {
-	puts("MMC:   ");
+	/* puts("MMC:   "); */
 	mmc_initialize(gd->bd);
 	return 0;
 }
diff --git common/image-fdt.c common/image-fdt.c
index 5e4e5bd..5a65aef 100644
--- common/image-fdt.c
+++ common/image-fdt.c
@@ -171,8 +171,8 @@ int boot_relocate_fdt(struct lmb *lmb, char **of_flat_tree, ulong *of_size)
 		 * for padding
 		 */
 		fdt_set_totalsize(of_start, of_len);
-		printf("   Using Device Tree in place at %p, end %p\n",
-		       of_start, of_start + of_len - 1);
+		/* printf("   Using Device Tree in place at %p, end %p\n", */
+		/*        of_start, of_start + of_len - 1); */
 	} else {
 		debug("## device tree at %p ... %p (len=%ld [0x%lX])\n",
 		      fdt_blob, fdt_blob + *of_size - 1, of_len, of_len);
@@ -375,8 +375,10 @@ int boot_get_fdt(int flag, int argc, char * const argv[], uint8_t arch,
 				 * FDT blob
 				 */
 				debug("*  fdt: raw FDT blob\n");
+#if 0
 				printf("## Flattened Device Tree blob at %08lx\n",
 				       (long)fdt_addr);
+#endif
 			}
 			break;
 		default:
@@ -384,7 +386,7 @@ int boot_get_fdt(int flag, int argc, char * const argv[], uint8_t arch,
 			goto no_fdt;
 		}
 
-		printf("   Booting using the fdt blob at %#08lx\n", fdt_addr);
+		/* printf("   Booting using the fdt blob at %#08lx\n", fdt_addr); */
 		fdt_blob = map_sysmem(fdt_addr, 0);
 	} else if (images->legacy_hdr_valid &&
 			image_check_type(&images->legacy_hdr_os_copy,
diff --git common/main.c common/main.c
index 5a03181..34c37ae 100644
--- common/main.c
+++ common/main.c
@@ -53,11 +53,17 @@ static void run_preboot_environment_command(void)
 #endif /* CONFIG_PREBOOT */
 }
 
+extern int board_rearcam_check(void);
 /* We come here after U-Boot is initialised and ready to process commands */
 void main_loop(void)
 {
 	const char *s;
 
+	if (board_rearcam_check()) {
+		s = getenv("bootcmd");
+		run_command_list(s, -1, 0);
+	}
+
 	bootstage_mark_name(BOOTSTAGE_ID_MAIN_LOOP, "main_loop");
 
 #ifndef CONFIG_SYS_GENERIC_BOARD
diff --git drivers/misc/Makefile drivers/misc/Makefile
index 8d1bdf9..7f8a429 100644
--- drivers/misc/Makefile
+++ drivers/misc/Makefile
@@ -42,3 +42,5 @@ obj-$(CONFIG_SENSORID) += sensorid-uclass.o
 obj-$(CONFIG_SENSORID_ARTIK) += sensorid_artik.o
 obj-$(CONFIG_USB_CHARGE) += usb_charge.o
 obj-$(CONFIG_UB927928) += ub927928.o
+# obj-$(CONFIG_CHECK_REARCAM) += nexell_i2c.o
+obj-y += nexell_i2c.o
diff --git drivers/misc/nexell_i2c.c drivers/misc/nexell_i2c.c
new file mode 100644
index 0000000..8a18c74
--- /dev/null
+++ drivers/misc/nexell_i2c.c
@@ -0,0 +1,172 @@
+/*
+ * (C) Copyright 2017 ZhongHong
+ *
+ * SPDX-License-Identifier:      GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+#include <dm.h>
+#include <errno.h>
+#include <i2c.h>
+#include <linux/time.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <nexell_i2c.h>
+
+/* #define msleep(a) udelay(a * 1000) */
+
+#define i2c_send_slave_addr 0x44 /* 927 */
+#define i2c_rev_slave_addr 0x2c /* 928 */
+
+struct nx_i2c_platdata {
+	struct gpio_desc gpio_en;
+};
+
+static int nx_i2c_read(struct udevice *dev,
+	unsigned char slave_addr, unsigned int cmd,
+	unsigned char *buf, int len)
+{
+	struct dm_i2c_chip *chip = dev_get_parent_platdata(dev);
+
+	chip->chip_addr = slave_addr;
+
+	return dm_i2c_read(dev, cmd, buf, len);
+}
+
+static int nx_i2c_write(struct udevice *dev,
+	unsigned char slave_addr, unsigned int cmd,
+	unsigned char *buf, int len)
+{
+	struct dm_i2c_chip *chip = dev_get_parent_platdata(dev);
+
+	chip->chip_addr = slave_addr;
+	chip->flags = DM_I2C_CHIP_WR_ADDRESS;
+
+	return dm_i2c_write(dev, cmd, buf, len);
+}
+
+int nx_i2c_set_mode(struct udevice *dev , int mode)
+{
+
+	return 0;
+}
+
+int nx_i2c_init(struct udevice *dev)
+{
+	int i;
+	int ret;
+	unsigned char data[1] = {0};
+
+	/* printf("nx_i2c_init-----\n"); */
+	u16 reg[] = {0x40, 0x07, 0x0b, 0x39, 0x4d, 0x4e, 0xc8, 0x73, 0xb9, 0x4e, 0x02, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a};
+	u16 val[] = {0x00, 0xc0, 0xc0, 0x8c, 0x03, 0x17, 0x21, 0x01, 0x01, 0x17, 0xcf, 0x13, 0x4e, 0x80, 0x13, 0xf0, 0x07};
+	
+	u16 reg1[] = {0x1c, 0x1d, 0x0c, 0x0d, 0x20, 0x26, 0x2b, 0x2d, 0x2d, 0x2e, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0xff};
+	u16 val1[] = {0x09, 0x38, 0x53, 0x10, 0xa0, 0x12, 0x70, 0x70, 0x68, 0x5e, 0x62, 0xbb, 0x96, 0xc0, 0x25, 0x84, 0xff};
+	for (i = 0; i < ARRAY_SIZE(reg); i++) {
+		ret = nx_i2c_write(dev, i2c_send_slave_addr,
+				reg[i], &val[i], 1);
+		//mdelay(1);
+	}
+	for (i = 0; i < ARRAY_SIZE(reg1); i++) {
+		ret = nx_i2c_write(dev, i2c_send_slave_addr,
+				reg1[i], &val1[i], 1);
+		//mdelay(1);
+	}
+
+	/* printf("nx_i2c_init-----ret[%d]\n" , ret); */
+
+	return 0;
+}
+static int nx_i2c_probe(struct udevice *dev)
+{
+	/* printf("nx_i2c_probe\n"); */
+
+	return 0;
+}
+static int nx_i2c_ofdata_to_platdata(struct udevice *dev)
+{
+	/*
+	struct nx_i2c_platdata *pdata = dev->platdata;
+	int ret;
+
+	ret = gpio_request_by_name(dev, "gpios-en",
+		0, &(pdata->gpio_en), GPIOD_IS_OUT);
+	if (ret) {
+		debug("%s: Could not decode sleep-gpios (%d)\n", __func__, ret);
+		return ret;
+	}
+
+	dm_gpio_set_value(&pdata->gpio_en , 1);
+	printf("nx_i2c_ofdata_to_platdata[%d]\n", pdata->gpio_en.offset);
+	*/
+
+	return 0;
+}
+
+static int nx_i2c_bind(struct udevice *dev)
+{
+	/*
+	struct gpio_desc power_en;
+	gpio_request_by_name(dev, "gpios-en", 0, &power_en,GPIOD_IS_OUT);
+	dm_gpio_set_value(&power_en , 0);
+	dm_i2c_read(dev,0x01, &value, 1);
+	*/
+
+	/* printf("nx_i2c_bind\n"); */
+
+	return 0;
+}
+
+static const struct udevice_id nx_i2c_ids[] = {
+	{ .compatible = "nexell,nx_i2c" },
+	{}
+};
+
+/*
+struct nx_i2c_ops {
+	int (*init)(struct udevice *dev);
+	int (*set_mode)(struct udevice *dev, int mode);
+};
+int nx_i2c_init(struct udevice *dev);
+int nx_i2c_set_mode(struct udevice *dev, int mode);
+*/
+
+static struct nx_i2c_ops i2c_ops = {
+	.init = nx_i2c_init,
+	.set_mode = nx_i2c_set_mode,
+};
+
+U_BOOT_DRIVER(nx_i2c) = {
+	.name = "nx_i2c",
+	.id = UCLASS_NX_I2C_ID,
+	.of_match = nx_i2c_ids,
+	.probe = nx_i2c_probe,
+	.bind = nx_i2c_bind,
+	.ofdata_to_platdata = nx_i2c_ofdata_to_platdata,
+	.platdata_auto_alloc_size = sizeof(struct nx_i2c_platdata),
+	.ops = &i2c_ops,
+};
+
+void nx_i2c_init_s(void)
+{
+	struct udevice *dev;
+	int ret;
+	const struct nx_i2c_ops *ops;
+
+	ret = uclass_get_device(UCLASS_NX_I2C_ID, 0, &dev);
+	if (ret)
+		return;
+
+	ops = device_get_ops(dev);
+	if (ops->init)
+		ret = ops->init(dev);
+	
+}
+
+UCLASS_DRIVER(nx_i2c) = {
+	.id = UCLASS_NX_I2C_ID,
+	.name = "nx_i2c",
+};
+
diff --git drivers/misc/ub927928.c drivers/misc/ub927928.c
index 059c6c0..048b751 100644
--- drivers/misc/ub927928.c
+++ drivers/misc/ub927928.c
@@ -77,7 +77,7 @@ int ub9xx_init(struct udevice *dev)
 
 	for (i = 0; i < 3; i++) {
 		ret = ub9xx_i2c_read(dev, i2c_rev_slave_addr, 0x1c, data, 1);
-		printf("ti927_Init: read reg:0x1c: 0x%x\n", data[0]);
+		/* printf("ti927_Init: read reg:0x1c: 0x%x\n", data[0]); */
 
 		if (data[0] == 0x03) {
 			printf("927,928 already lock\n");
@@ -93,7 +93,7 @@ int ub9xx_init(struct udevice *dev)
 	}
 
 	ret = ub9xx_i2c_read(dev, i2c_rev_slave_addr, 0x21, data, 1);
-	printf("ti927_Init: read reg:0x21: 0x%x\n", data[0]);
+	/* printf("ti927_Init: read reg:0x21: 0x%x\n", data[0]); */
 
 	if ((data[0] & 0xf0) == 0x90) {
 		printf("927,928 already init\n");
@@ -106,7 +106,7 @@ int ub9xx_init(struct udevice *dev)
 	for (i = 0; i < ARRAY_SIZE(reg); i++) {
 		ret = ub9xx_i2c_write(dev, i2c_send_slave_addr,
 				reg[i], &val[i], 1);
-		mdelay(1);
+		/* mdelay(1); */
 	}
 
 	/* 928 write */
@@ -114,13 +114,13 @@ int ub9xx_init(struct udevice *dev)
 		ret = ub9xx_i2c_write(dev, i2c_rev_slave_addr,
 				reg1[i], &val1[i], 1);
 
-	printf("ub927928_init-----ret[%d]\n" , ret);
+	/* printf("ub927928_init-----ret[%d]\n" , ret); */
 
 	return 0;
 }
 static int ub927928_probe(struct udevice *dev)
 {
-	printf("ub927928_probe\n");
+	/* printf("ub927928_probe\n"); */
 
 	return 0;
 }
@@ -153,7 +153,7 @@ static int ub927928_bind(struct udevice *dev)
 	dm_i2c_read(dev,0x01, &value, 1);
 	*/
 
-	printf("ub927928_bind\n");
+	/* printf("ub927928_bind\n"); */
 
 	return 0;
 }
diff --git drivers/misc/usb_charge.c drivers/misc/usb_charge.c
index 264eaba..be3a5e1 100644
--- drivers/misc/usb_charge.c
+++ drivers/misc/usb_charge.c
@@ -88,13 +88,13 @@ int e522xx_set_mode(struct udevice *dev , int mode)
 	if (mode > E_E522XX_PORT_CONF_CCP || mode < 0)
 		return -1;
 
-	printf("e522xx_set_mode [%d]\n", mode);
+	/* printf("e522xx_set_mode [%d]\n", mode); */
 	e522xx_state_ctrl(dev, E_E522XX_STATE_STANDBY);
 
 	/* status */
 	cmd = 0x10;
 	ret = e522xx_i2c_read(dev, cmd, buf, 1);
-	printf("read status reg 0x%x value=0x%x\n", cmd, buf[0]);
+	/* printf("read status reg 0x%x value=0x%x\n", cmd, buf[0]); */
 
 	/* SMPS */
 	cmd = 0x1A;
@@ -131,7 +131,7 @@ int e522xx_set_mode(struct udevice *dev , int mode)
 		cmd = 0x01;
 		/* 0x0c(DCP-BC1.2)  0X10(CCP FOR APPLE) 0x08(CDP)  0x14(CCP) */
 		buf[0] = 0x0c;
-		printf("DCP-BC1.2\n");
+		/* printf("DCP-BC1.2\n"); */
 		ret = e522xx_i2c_write(dev, cmd, buf, 1);
 		if (ret)
 			printf("usb_i2c_Write fail2==%d\n", ret);
@@ -142,7 +142,7 @@ int e522xx_set_mode(struct udevice *dev , int mode)
 		cmd = 0x01;
 		/* 0x0c(DCP-BC1.2)  0X10(CCP FOR APPLE) 0x08(CDP)  0x14(CCP) */
 		buf[0] = 0x10;
-		printf("CCP APPLE\n");
+		/* printf("CCP APPLE\n"); */
 		ret = e522xx_i2c_write(dev, cmd, buf, 1);
 		if (ret)
 			printf("usb_i2c_Write fail2==%d\n", ret);
@@ -153,7 +153,7 @@ int e522xx_set_mode(struct udevice *dev , int mode)
 		cmd = 0x01;
 		/* 0x0c(DCP-BC1.2)  0X10(CCP FOR APPLE) 0x08(CDP)  0x14(CCP) */
 		buf[0] = 0x14;
-		printf("CCP\n");
+		/* printf("CCP\n"); */
 		ret = e522xx_i2c_write(dev, cmd, buf, 1);
 		if (ret)
 			printf("usb_i2c_Write fail2==%d\n", ret);
@@ -164,7 +164,7 @@ int e522xx_set_mode(struct udevice *dev , int mode)
 		cmd = 0x01;
 		/* 0x0c(DCP-BC1.2)  0X10(CCP FOR APPLE) 0x08(CDP)  0x14(CCP) */
 		buf[0] = 0x1c;
-		printf("AUTO\n");
+		/* printf("AUTO\n"); */
 		ret = e522xx_i2c_write(dev, cmd, buf, 1);
 		if (ret)
 			printf("usb_i2c_Write fail2==%d\n", ret);
@@ -177,8 +177,8 @@ int e522xx_set_mode(struct udevice *dev , int mode)
 	e522xx_state_ctrl(dev, E_E522XX_STATE_RUN);
 	if (ret)
 		printf("e522xx_set_mode [%d] fail\n", mode);
-	else
-		printf("e522xx_set_mode [%d] success\n", mode);
+	/* else */
+	/* 	printf("e522xx_set_mode [%d] success\n", mode); */
 
 	return ret;
 }
@@ -189,7 +189,7 @@ int e522_init(struct udevice *dev)
 
 	e522xx_set_mode(dev , E_E522XX_PORT_CONF_CDP);
 	/* dm_i2c_read(dev,0x84, &value, 1); */
-	printf("usb_charge_init\n");
+	/* printf("usb_charge_init\n"); */
 
 	return 0;
 }
diff --git drivers/mmc/mmc.c drivers/mmc/mmc.c
index 3a34028..a594cf7 100644
--- drivers/mmc/mmc.c
+++ drivers/mmc/mmc.c
@@ -1667,11 +1667,112 @@ static int mmc_complete_init(struct mmc *mmc)
 	return err;
 }
 
+static void dump_mmc(struct mmc *mmc)
+{
+	printf("mmc info\n");
+	if (mmc->cfg) {
+		printf("cfg: name %s\n", mmc->cfg->name);
+		printf("cfg: ops %p\n", mmc->cfg->ops);
+		printf("cfg: host_caps 0x%x\n", mmc->cfg->host_caps);
+		printf("cfg: voltages 0x%x\n", mmc->cfg->voltages);
+		printf("cfg: f_min %d\n", mmc->cfg->f_min);
+		printf("cfg: f_max %d\n", mmc->cfg->f_max);
+		printf("cfg: b_max %d\n", mmc->cfg->b_max);
+		printf("cfg: part_type %d\n", mmc->cfg->part_type);
+	}
+	printf("version: %d\n", mmc->version);
+	printf("priv: %p\n", mmc->priv);
+	printf("high_capacity: %d\n", mmc->high_capacity);
+	printf("bus_width: %d\n", mmc->bus_width);
+	printf("clock: %d\n", mmc->clock);
+	printf("card_caps: 0x%x\n", mmc->card_caps);
+	printf("ocr: 0x%x\n", mmc->ocr);
+	printf("dsr: 0x%x\n", mmc->dsr);
+	printf("dsr_imp: 0x%x\n", mmc->dsr_imp);
+	printf("scr: 0x%x 0x%x\n", mmc->scr[0], mmc->scr[1]);
+	printf("csd: 0x%x 0x%x 0x%x 0x%x\n", mmc->csd[0], mmc->csd[1],
+	       mmc->csd[2], mmc->csd[3]);
+	printf("cid: 0x%x 0x%x 0x%x 0x%x\n", mmc->cid[0], mmc->cid[1],
+	       mmc->cid[2], mmc->cid[3]);
+	printf("rca: 0x%x\n", mmc->rca);
+	printf("part_support: %d\n", mmc->part_support);
+	printf("part_num: %d\n", mmc->part_num);
+	printf("tran_speed: %d\n", mmc->tran_speed);
+	printf("read_bl_len: %d\n", mmc->read_bl_len);
+	printf("write_bl_len: %d\n", mmc->write_bl_len);
+	printf("erase_grp_size: %d\n", mmc->erase_grp_size);
+	printf("hc_wp_grp_size: %d\n", mmc->hc_wp_grp_size);
+	printf("capacity: %llu\n", mmc->capacity);
+	printf("capacity_user: %llu\n", mmc->capacity_user);
+	printf("capacity_rpmb: %llu\n", mmc->capacity_rpmb);
+	printf("capacity_gp: %d %d %d %d\n", mmc->capacity_gp[0],
+	       mmc->capacity_gp[1], mmc->capacity_gp[2], mmc->capacity_gp[3]);
+	printf("enh_user_start: %d\n", mmc->enh_user_start);
+	printf("enh_user_size: %d\n", mmc->enh_user_size);
+	printf("ddr_mode: %d\n", mmc->ddr_mode);
+}
+
+extern int board_rearcam_check(void);
 int mmc_init(struct mmc *mmc)
 {
 	int err = 0;
 	unsigned start;
 
+	if (mmc->has_init == 1)
+		return 0;
+
+	/* psw0523 hack */
+	if (board_rearcam_check()) {
+		mmc->has_init = 1;
+		mmc->version = 1074069504;
+		mmc->high_capacity = 1;
+		mmc->bus_width = 4;
+		mmc->clock = 50000000;
+		mmc->card_caps = 0x7;
+		mmc->ocr = 0xc0ff8080;
+		mmc->dsr = 0xffffffff;
+		mmc->dsr_imp = 0x0;
+		mmc->scr[0] = 0x0;
+		mmc->scr[1] = 0x0;
+		mmc->csd[0] = 0xd0270032;
+		mmc->csd[1] = 0xf5903ff;
+		mmc->csd[2] = 0xffffffe7;
+		mmc->csd[3] = 0x8640009b;
+		mmc->cid[0] = 0x11010030;
+		mmc->cid[1] = 0x31364737;
+		mmc->cid[2] = 0x30004a3a;
+		mmc->cid[3] = 0x6ccba3b7;
+		mmc->rca = 0x1;
+		mmc->part_support = 7;
+		mmc->part_num = 0;
+		mmc->tran_speed = 52000000;
+		mmc->read_bl_len = 512;
+		mmc->write_bl_len = 512;
+		mmc->erase_grp_size = 1024;
+		mmc->hc_wp_grp_size = 8192;
+		mmc->capacity = 15758000128;
+		mmc->capacity_user = 15758000128;
+		mmc->capacity_rpmb = 4194304;
+		mmc->capacity_gp[0] = 0;
+		mmc->capacity_gp[1] = 0;
+		mmc->capacity_gp[2] = 0;
+		mmc->capacity_gp[3] = 0;
+		mmc->enh_user_start = 8;
+		mmc->enh_user_size = 8;
+		mmc->ddr_mode = 0;
+
+		mmc->block_dev.lun = 0;
+		mmc->block_dev.type = 0;
+		mmc->block_dev.blksz = mmc->read_bl_len;
+		mmc->block_dev.log2blksz = LOG2(mmc->block_dev.blksz);
+		mmc->block_dev.lba = lldiv(mmc->capacity, mmc->read_bl_len);
+		mmc->block_dev.vendor[0] = 0;
+		mmc->block_dev.product[0] = 0;
+		mmc->block_dev.revision[0] = 0;
+
+		init_part(&mmc->block_dev);
+	}
+
 	if (mmc->has_init)
 		return 0;
 
@@ -1683,6 +1784,9 @@ int mmc_init(struct mmc *mmc)
 	if (!err)
 		err = mmc_complete_init(mmc);
 	debug("%s: %d, time %lu\n", __func__, err, get_timer(start));
+
+	/* dump_mmc(mmc); */
+
 	return err;
 }
 
@@ -1814,10 +1918,12 @@ int mmc_initialize(bd_t *bis)
 		return ret;
 
 #ifndef CONFIG_SPL_BUILD
-	print_mmc_devices(',');
+	/* print_mmc_devices(','); */
 #endif
 
+#if 0
 	do_preinit();
+#endif
 	return 0;
 }
 
diff --git drivers/mmc/nexell_dw_mmc.c drivers/mmc/nexell_dw_mmc.c
index 8d4acbc..56416b1 100644
--- drivers/mmc/nexell_dw_mmc.c
+++ drivers/mmc/nexell_dw_mmc.c
@@ -356,7 +356,7 @@ static int nx_dw_mmc_setup(const void *blob)
 
 		nx_dw_mmc_set_pin(host);
 		nx_dw_mmc_set_clk(host, priv->frequency * 4);
-		nx_dw_mmc_reset(host->dev_index);
+		/* nx_dw_mmc_reset(host->dev_index); */
 		nx_dw_mmc_clk_delay(host);
 
 		/* add to dwmci */
diff --git drivers/power/pmic/nxe2000.c drivers/power/pmic/nxe2000.c
index 108f0d4..572e439 100644
--- drivers/power/pmic/nxe2000.c
+++ drivers/power/pmic/nxe2000.c
@@ -384,7 +384,7 @@ static int nxe2000_probe(struct udevice *dev)
 	nxe2000_reg_dump(dev, "PMIC Setup Register Dump");
 #endif
 
-	nxe2000_print_chgstate(dev);
+	/* nxe2000_print_chgstate(dev); */
 
 	return 0;
 }
diff --git drivers/power/regulator/nxe2000.c drivers/power/regulator/nxe2000.c
index 15c233f..d83185b 100644
--- drivers/power/regulator/nxe2000.c
+++ drivers/power/regulator/nxe2000.c
@@ -410,9 +410,11 @@ static int nxe2000_buck_probe(struct udevice *dev)
 	else if (pdata->on == 0)
 		nxe2000_buck_set_enable(dev, 0);
 
+#if 0
 	printf("DCDC%lu: %4dmV, %s\n", (dev->driver_data+1)
 		, nxe2000_buck_get_value(dev)/1000
 		, nxe2000_buck_get_enable(dev) ? "En" : "Dis");
+#endif
 
 	return 0;
 }
diff --git drivers/video/cfb_console.c drivers/video/cfb_console.c
index 4b5291b..956ccc1 100644
--- drivers/video/cfb_console.c
+++ drivers/video/cfb_console.c
@@ -1926,6 +1926,15 @@ static void plot_logo_or_black(void *screen, int x, int y, int black)
 #endif
 }
 
+/*
+ *  * Implement a weak default function for boards that optionally
+ *   * need to skip the log display if rearcam is on
+ *    */
+int __weak board_rearcam_check(void)
+{
+	return 0;
+}
+
 static void *video_logo(void)
 {
 	char info[128];
@@ -1934,6 +1943,9 @@ static void *video_logo(void)
 	__maybe_unused ulong addr;
 	__maybe_unused char *s;
 
+	if (board_rearcam_check())
+		return 0;
+
 	splash_get_pos(&video_logo_xpos, &video_logo_ypos);
 
 #ifdef CONFIG_SPLASH_SCREEN
diff --git drivers/video/nexell/s5pxx18_dp_lvds.c drivers/video/nexell/s5pxx18_dp_lvds.c
index 45bfd13..dd39c9f 100644
--- drivers/video/nexell/s5pxx18_dp_lvds.c
+++ drivers/video/nexell/s5pxx18_dp_lvds.c
@@ -65,10 +65,12 @@ static int lvds_setup(int module, int input,
 		voltage = dev->voltage_level;
 	}
 
+#if 0
 	printf("LVDS:");
 	printf("%s, ", format == DP_LVDS_FORMAT_VESA ? "VESA" :
 		format == DP_LVDS_FORMAT_JEIDA ? "JEIDA" : "LOC");
 	printf("voltage LV:0x%x\n", voltage);
+#endif
 
 
 	/*
@@ -229,7 +231,7 @@ void nx_lvds_display(int module,
 	int count = top->plane_num;
 	int i = 0;
 
-	printf("LVDS: dp.%d\n", module);
+	/* printf("LVDS: dp.%d\n", module); */
 
 	dp_control_init(module);
 	dp_plane_init(module);
diff --git drivers/video/nexell_display.c drivers/video/nexell_display.c
index 301a3f9..b5fc090 100644
--- drivers/video/nexell_display.c
+++ drivers/video/nexell_display.c
@@ -468,10 +468,10 @@ static struct nx_display_dev *nx_display_setup(void)
 		goto err_setup;
 	};
 
-	printf("LCD: [%s] dp.%d.%d %dx%d %dbpp FB:0x%08x\n",
-	       dp_dev_str[dp->dev_type], dp->module, dp->fb_plane->layer,
-	       dp->fb_plane->width, dp->fb_plane->height, dp->depth * 8,
-	       dp->fb_addr);
+	/* printf("LCD: [%s] dp.%d.%d %dx%d %dbpp FB:0x%08x\n", */
+	/*        dp_dev_str[dp->dev_type], dp->module, dp->fb_plane->layer, */
+	/*        dp->fb_plane->width, dp->fb_plane->height, dp->depth * 8, */
+	/*        dp->fb_addr); */
 
 	return dp;
 
diff --git include/configs/s5p4418_zh_blackdragon.h include/configs/s5p4418_zh_blackdragon.h
index 0695169..33415e4 100644
--- include/configs/s5p4418_zh_blackdragon.h
+++ include/configs/s5p4418_zh_blackdragon.h
@@ -351,4 +351,6 @@
 #define CONFIG_SW_UBC_DETECT
 /* #define CONFIG_PMIC_REG_DUMP */
 
+#define CONFIG_SYS_CONSOLE_INFO_QUIET
+
 #endif /* __CONFIG_H__ */
diff --git include/dm/uclass-id.h include/dm/uclass-id.h
index 55e1a5e..6639dc6 100644
--- include/dm/uclass-id.h
+++ include/dm/uclass-id.h
@@ -73,7 +73,7 @@ enum uclass_id {
 	UCLASS_SENSOR_ID,	/* Sensor type detecting device */
 	UCLASS_USBCHARGE_ID,	/* USB Charger */
 	UCLASS_UB927928_ID,     /* Serdes */
-
+	UCLASS_NX_I2C_ID,
 	UCLASS_COUNT,
 	UCLASS_INVALID = -1,
 };
diff --git include/nexell_i2c.h include/nexell_i2c.h
new file mode 100644
index 0000000..0d0a0ff
--- /dev/null
+++ include/nexell_i2c.h
@@ -0,0 +1,19 @@
+/*
+ * (C) Copyright 2017 ZhongHong
+ *
+ * SPDX-License-Identifier:      GPL-2.0+
+ */
+
+#ifndef __NEXELL_I2C_H
+#define __NEXELL_I2C_H
+
+struct nx_i2c_ops {
+	int (*init)(struct udevice *dev);
+	int (*set_mode)(struct udevice *dev, int mode);
+};
+
+int nx_i2c_init(struct udevice *dev);
+int nx_i2c_set_mode(struct udevice *dev, int mode);
+void nx_i2c_init_s(void);
+#endif
+
